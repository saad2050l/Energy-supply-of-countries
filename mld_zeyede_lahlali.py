# -*- coding: utf-8 -*-
"""MLD_Zeyede-Lahlali.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n6gLRr_Gg9LfPGf1ApB8KsXv0xKmPi-q

# Importing libraries
"""

# Commented out IPython magic to ensure Python compatibility.
# Data analysis, visualization
import numpy as np 
import pandas as pd 
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

# Kmeans
from sklearn.metrics import silhouette_score
from sklearn.cluster import KMeans

# PCA
from sklearn.decomposition import PCA

# World Map
import pycountry
import geopandas
import mapclassify

"""# Data Exploration and Analysis

## Importing the Data
"""

df = pd.read_csv(r'/content/drive/MyDrive/Energy_stats/all_energy_statistics.csv')
df.head()

g20_countries = 'Australia', 'Canada', 'Saudi Arabia', 'United States', 'India', 'Russian Federation', 'South Africa', 'Turkey', 'Argentina',\
                  'Brazil', 'Mexico', 'Spain', 'France', 'Germany', 'Italy', 'United Kingdom', 'China', 'Indonesia', 'Japan', 'Korea, Republic of', 'Others'

nRow, nCol = df.shape
print(f'There are {nRow} rows and {nCol} columns')

"""## Exploration

### Plots of different columns
"""

countries_count_sort = sorted(dict(df['country_or_area'].value_counts()).items(), key=lambda x: x[1])
year_count_sort = sorted(dict(df['year'].value_counts()).items(), key=lambda x: x[1])
unit_count_sort = sorted(dict(df['unit'].value_counts()).items(), key=lambda x: x[1])
category_count_sort = sorted(dict(df['category'].value_counts()).items(), key=lambda x: x[1])
commodity_transaction_count_sort = sorted(dict(df['commodity_transaction'].value_counts()).items(), key=lambda x: x[1])

def plot_count(lst, keep, title, figsize):
  
  fig, ax = plt.subplots(figsize=figsize) 
  X = [w[0] for w in lst[len(lst)-keep:]][::-1]
  y_pos = np.arange(len(X))
  Y = [w[1] for w in lst[len(lst)-keep:]][::-1]
  ax.barh(y_pos, Y, color=['#ff9999','#66b3ff','#99ff99','#ffcc99', 'mediumslateblue'], align='center')
  ax.set_yticks(y_pos)
  ax.set_yticklabels(X)
  ax.invert_yaxis() 
  ax.set_title(title)
  plt.show()

labels = 'G20 (20 Countries)', 'Others (223 Countries)'
g20_entries = round((sum([x[1] for x in countries_count_sort if x[0] in g20_countries])/len(df))*100, 2)
sizes = [g20_entries, 100-g20_entries]
explode = (0.1, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')

fig1, ax1 = plt.subplots(figsize=(5,5))
ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',
        shadow=True, startangle=90, colors=['#ff9999','#66b3ff'])
ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

plt.show()

plot_count(countries_count_sort, 20, '', (15,15))

avg_n_entries_1990s = sum([x[1] for x in year_count_sort if x[0] < 2000])/len([x[1] for x in year_count_sort if x[0] < 2000])
avg_n_entries_2000s = sum([x[1] for x in year_count_sort if x[0] >= 2000])/len([x[1] for x in year_count_sort if x[0] >=2000])

plot_count(year_count_sort, len(year_count_sort), 'year', (12,10))

plot_count(unit_count_sort, len(unit_count_sort), '', (10,7))

plot_count(commodity_transaction_count_sort, 20, 'Commodity_Transaction', (12,15))

"""### Evolution of some energy sources use by country between 1990 and 2015"""

df.describe()

top_10_countrys=list(df.country_or_area.value_counts().head(10).index)
print(top_10_countrys)

# df_top10=df[df.country_or_area.isin(top_10_countrys)]
df[['country_or_area', 'commodity_transaction', 'year', 'unit', 'quantity']].head()

df_top10[df_top10["commodity_transaction"].str.contains('Electricity')].groupby(by=['country_or_area','year']).sum()['quantity'].unstack(level=0).plot(logy=True,
                                                                                                                                                       figsize=(10,7),
                                                                                                                                                       fontsize=13,
                                                                                                                                                       grid=True,
                                                                                                                                                       title = 'Electricity',
                                                                                                                                                       ylabel='quantity')

countries = ['United States', 'United Kingdom', 'China', 'Mexico','Russian Federation', 'Norway', 
             'Saudi Arabia', 'Iran (Isalmic Rep. of)']
oil_groups = df[(df["commodity_transaction"].str.contains('Conventional crude oil - production')) & (df['country_or_area'].isin(countries))].groupby(by=['country_or_area','year']).sum().sort_values('quantity',ascending=False)
oil_groups.head(250)['quantity'].unstack(level=0).plot(logy=True, fontsize=13, grid=True, ylabel='Quantity (Metric tons, thousand)', xlabel='Year', figsize=(10,6), marker='.')

df_top10[df_top10["commodity_transaction"].str.contains('Coal')].groupby(by=['country_or_area','year']).sum()['quantity'].unstack(level=0).plot(logy=True,
                                                                                                                                                       figsize=(10,7),
                                                                                                                                                       fontsize=13,
                                                                                                                                                       grid=True,
                                                                                                                                                       title = 'Coal',
                                                                                                                                                       ylabel='Quantity')

df_top10[df_top10["commodity_transaction"].str.contains('Solar')].groupby(by=['country_or_area','year']).sum()['quantity'].unstack(level=0).plot(logy=True,
                                                                                                                                                 
                                                                                                                                                       figsize=(10,7),
                                                                                                                                                       fontsize=13,
                                                                                                                                                       grid=True,
                                                                                                                                                       title = 'Solar',
                                                                                                                                                       ylabel='Quantity')

df_top10[df_top10["commodity_transaction"].str.contains('Wind')].groupby(by=['country_or_area','year']).sum()['quantity'].unstack(level=0).plot(logy=True,
                                                                                                                                                       figsize=(10,7),
                                                                                                                                                       fontsize=13,
                                                                                                                                                       grid=True,
                                                                                                                                                       title = 'Wind',
                                                                                                                                                       ylabel='Quantity')

df_top10[df_top10["commodity_transaction"].str.contains('Imports')].groupby(by=['country_or_area','year']).sum()['quantity'].unstack(level=0).plot(logy=True,
                                                                                                                                                       figsize=(10,7),
                                                                                                                                                       fontsize=13,
                                                                                                                                                       grid=True,
                                                                                                                                                       title = 'Imports',
                                                                                                                                                       ylabel='Quantity')

df_top10[df_top10["commodity_transaction"].str.contains('Exports')].groupby(by=['country_or_area','year']).sum()['quantity'].unstack(level=0).plot(logy=True,
                                                                                                                                                       figsize=(10,7),
                                                                                                                                                       fontsize=13,
                                                                                                                                                       grid=True,
                                                                                                                                                       title = 'Exports',
                                                                                                                                                       ylabel='Quantity')

"""## Preparation"""

#The indicators of interest
indicators = [ 'Electricity - total geothermal production',
 'Electricity - total hydro production',
 'Electricity - total nuclear production',
 'Electricity - total solar production',
 'Electricity - total thermal production',
 'Electricity - total tide, wave production',
 'Electricity - total wind production' 
 ]

#Keeping only the rows of interest
df_energy_sup = df.loc[df['commodity_transaction'].isin(indicators)][['country_or_area',	'commodity_transaction',	'year',	'quantity']]
df_energy_sup.head()

# One_hot encoding the data
one_hot = pd.get_dummies(df_energy_sup['commodity_transaction'])
one_hot = one_hot.astype(np.float64)
one_hot

identifiers = ['country_or_area', 'year']
# multiply one hot with the quantities
values = df_energy_sup[['quantity']].reset_index(drop=True)
for col in one_hot.columns.values:
  values[col] = values['quantity']*one_hot[col].squeeze().values
values = values.drop(['quantity'], axis=1)

# concat country name and year
cols = df_energy_sup[['country_or_area', 'year']].reset_index(drop=True)
values = pd.concat([cols, values], axis=1)

# normalize each column
for column in values.columns.values:
  if column in identifiers:
    continue
  values[column] = (values[column] - values[column].min()) / (values[column].max() - values[column].min())

# get the total energy supply
values['total energy supply'] = values.iloc[:, 2:].sum(axis=1)
values = values.groupby(identifiers).sum().dropna().reset_index()
values = pd.concat([values[identifiers], values.iloc[:,3:].div(values['total energy supply'], axis=0)], axis=1)
values[values['country_or_area'] == 'China']

# Grouping the data by country and year
dframe = values.groupby(identifiers).sum().dropna()
dframe

# Droping the total energy supply column
dframe =dframe.drop('total energy supply', 1)
dframe

"""# Data Clustering

## Kmeans

### Optimal number of clusters search
"""

X = dframe.values.tolist()

l_sil, l_in = [], []
h = 25
for k in range(2, h):
  kmeans = KMeans(n_clusters = k)
  kmeans.fit(X)
  kmeans_prediction = kmeans.predict(X)
  silhouette_avg_ = silhouette_score(X, kmeans_prediction)
  l_sil.append(silhouette_avg_)
  l_in.append(kmeans.inertia_)

fig, ax1 = plt.subplots(figsize=(12,7))
X = range(2, h)

ax1.set_xlabel('Number of clusters', fontsize=15)
ax1.set_ylabel('Sum of Squared Errors', fontsize=15, color='green')
ax1.plot(X, l_in, color='green', marker='o')
ax1.plot([8,8],[0,790], linestyle='dashed', color='red')
ax1.set_xticks(X)

ax2 = ax1.twinx()
ax2.set_ylabel('Silhouette', fontsize=15, color='blue')
ax2.plot(X, l_sil, color='blue', marker='o')

plt.grid()
#plt.title('K Means number of clusters optimization', fontsize=15)
fig.tight_layout()  
plt.show()

"""### Kmeans model with optimal number of clusters"""

opti_n_clusters = 8

X = dframe.values.tolist()
kmeans = KMeans(n_clusters = opti_n_clusters)
kmeans.fit(X)
kmeans_prediction = kmeans.predict(X)

"""### Visualization of cluster centers vectors"""

h = 1
re = ['Electricity - total solar production', 'Electricity - total tide, wave production', 'Electricity - total wind production']
for j, c in enumerate(kmeans.cluster_centers_[:2]):
  d1 = [w/sum(c)*100 for w in c]

  ind_sort = sorted(range(len(d1)), key=d1.__getitem__)[::-1]
  a = [d1[i] for i in ind_sort[:h]]
  b = [dframe.columns[i].replace('total','').replace('Electricity - ','').replace('production','').replace(' ','').capitalize() for i in ind_sort[:h]] #.split('-')[0]

  labels = b+['Other']
  sizes = a+[100-sum(a)]
  explode = (0.2, 0) 

  fig1, ax1 = plt.subplots()
  ax1.set_title('Group '+str(j))
  colors = ['#66b3ff', '#ff9999','#99ff99','#66b3ff']
  ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',colors=colors,
          shadow=True, startangle=90)
  ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

  plt.show()

h = 3
re = ['Electricity - total solar production', 'Electricity - total tide, wave production', 'Electricity - total wind production']
for j, c in enumerate(kmeans.cluster_centers_):
  d1 = [w/sum(c)*100 for w in c]

  ind_sort = sorted(range(len(d1)), key=d1.__getitem__)[::-1]
  a = [d1[i] for i in ind_sort[:h]]
  b = [dframe.columns[i].replace('total','').replace('Electricity - ','').replace('production','').replace(' ','').capitalize() for i in ind_sort[:h]] #.split('-')[0]

  labels = b+['Other']
  sizes = a+[100-sum(a)]
  explode = tuple([0.1]+[0]*(len(sizes)-1))  

  fig1, ax1 = plt.subplots()
  ax1.set_title('Group '+str(j))
  colors = ['#66b3ff', '#ff9999','#99ff99','#ffcc99', 'mediumslateblue' ]
  ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',colors=colors,
          shadow=True, startangle=90)
  ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

  plt.show()

"""### Clusters Distribution"""

np.bincount(kmeans_prediction)

df_predict = pd.DataFrame(data=kmeans_prediction)
clustered_df = pd.concat([dframe.reset_index(), df_predict], axis=1)

"""## PCA

### Dimensionality Reduction
"""

dframe = dframe.astype(np.float16)
X = dframe.values.tolist()

pca = PCA(n_components=len(dframe.columns), svd_solver='randomized',
          whiten=True)

pca = pca.fit(X)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(25,7))

ax1.plot(range(1,len(dframe.columns)+1),pca.explained_variance_ratio_)
ax1.set_ylabel("Ratio of explained variance", size = 14)
ax1.set_xlabel("Principal component", size = 14)
ax1.set_xticks(range(1,len(dframe.columns)+1))
ax1.grid()

percentage_var_explained = pca.explained_variance_ / np.sum(pca.explained_variance_);
cum_var_explained = np.cumsum(percentage_var_explained)
ax2.plot(range(1,len(dframe.columns)+1),cum_var_explained, linewidth=2)
ax2.axis('tight')
ax2.grid()
ax2.set_xlabel('Number of components', size = 14)
ax2.set_ylabel('Cumulative explained variance', size = 14)

plt.subplots_adjust(bottom=0.15, wspace=0.15)
plt.show()

pca.components_

"""### Data Projection on 2D space"""

plt.figure(figsize=(10, 7))
colors = ['gray', 'turquoise', 'blue', 'lime', 'coral', 'pink', 'green', 'orange', 'darkslateblue', 'indigo',
          'seagreen', 'darkorange', 'aquamarine', 'gold', 'maroon', 'aqua']
lw = 2
X_r = pca.transform(X)
km_x = [w[0] for w in X_r[:]]
km_y = [w[1] for w in X_r[:]]
kmeans_prediction = kmeans.predict(X)[:]

for x, y, label in zip(km_x, km_y, kmeans_prediction):  
  plt.scatter(x, y, color=colors[label])

centers = pca.transform(kmeans.cluster_centers_)
km_x = [w[0] for w in centers]
km_y = [w[1] for w in centers]
kmeans_prediction = kmeans.predict(kmeans.cluster_centers_)
for i in range(len(km_x)):  
  plt.scatter(km_x[i], km_y[i], color=colors[kmeans_prediction[i]],
                label=kmeans_prediction[i], s=30)
  
for i in range(len(km_x)):  
  plt.text(km_x[i], km_y[i], str(i), dict(size=20), color='red', horizontalalignment='center',
     verticalalignment='center')


#plt.title('Projection of the dataset on the sub space formed by the first two components', size=15)
plt.xlabel('First Component', size=13)
plt.ylabel('Second Component', size=13)
plt.legend()
plt.show()

"""## World Map visualization of clusters"""

def alpha3code(column):
    CODE=[]
    for country in column:
        try:
          if country == 'Dem. Rep. of the Congo':
            CODE.append('COD')
          elif country == 'Central African Rep.':
            CODE.append('CAF')
          elif country == 'United Rep. of Tanzania':
            CODE.append('TZA')
          elif country == 'Bolivia (Plur. State of)':
            CODE.append('BOL')
          elif country == 'Venezuela (Bolivar. Rep.)':
            CODE.append('VEN')
          else:
            code=pycountry.countries.get(name=country).alpha_3
            # .alpha_3 means 3-letter country code 
            # .alpha_2 means 2-letter country code
            CODE.append(code)
        except:
            CODE.append('None')
    return CODE
# create a column for code

def plot_map(year):

  cluster_for_viz = clustered_df.copy(deep=True)
  cluster_for_viz = cluster_for_viz.rename(columns={0: 'cluster'}, errors="raise")
  cluster2013 = cluster_for_viz.copy(deep=True).loc[(clustered_df['year']==year)]

  cluster2013['CODE']=alpha3code(cluster2013.country_or_area)

  world = geopandas.read_file(geopandas.datasets.get_path('naturalearth_lowres'))
  # rename the columns so that we can merge with our data
  world.loc[world['name'] == 'France', 'iso_a3'] = 'FRA'
  world.loc[world['name'] == 'Norway', 'iso_a3'] = 'NOR'
  world.loc[world['name'] == 'Somaliland', 'iso_a3'] = 'SOM'
  world.loc[world['name'] == 'Kosovo', 'iso_a3'] = 'RKS'
  world.loc[world['name'] == 'Dem. Rep. Congo', 'name'] = 'Dem. Rep. of the Congo'
  world.columns=['pop_est', 'continent', 'name', 'CODE', 'gdp_md_est', 'geometry']
  # then merge with our data 
  merge=pd.merge(world,cluster2013,on='CODE')
  # last thing we need to do is - merge again with our location data which contains each countryâ€™s latitude and longitude
  location=pd.read_csv('https://raw.githubusercontent.com/melanieshi0120/COVID-19_global_time_series_panel_data/master/data/countries_latitude_longitude.csv')
  location = location.append([{'name': 'France','longitude': 46.227638,'latitude': 2.213749},
                              {'name': 'Norway','longitude': 60.472024,'latitude': 8.468946},
                              {'name': 'Kosovo','longitude': -0.228021,'latitude': 20.902977},
                              {'name': 'Dem. Rep. of the Congo','longitude': 42.602636,'latitude': 15.827659}], ignore_index=True)
  merge=merge.merge(location,on='name').sort_values(by='cluster',ascending=False).reset_index()

  merge[merge['name'].str.contains('Congo')]
  # location[location['name'] == 'Congo']
  world[world['name'].str.contains('Venezuela')]
  # cluster2013[cluster2013['country_or_area'].str.contains('Venezuela')].head()


  # plot cluster world map
  merge.plot(column='cluster',categorical=True, 
            figsize=(25, 20),
            legend=True,cmap='coolwarm') 
  plt.title(str(year)+' Countries cluster by similarity in sources of energy',fontsize=25)
  # add countries names and numbers 
  for i in range(0,10):
      plt.text(float(merge.longitude[i]),float(merge.latitude[i]),"{}\n{}".format(merge.name[i],merge.cluster[i]),size=10)
  plt.show()

for i in range(1990, 2015):
  plot_map(i)